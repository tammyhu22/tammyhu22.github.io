<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <script src = "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js"></script>
        <title>sound</title>
        <style>
        html,
        body {
            padding:0;
            margin:0;
            overflow:hidden;
        }
        </style>
        <script>
            let t = 0;
            let r,g,b;
            let movingRight = true;

            let IBM;
            function preload() {
            IBM = loadFont('assets/IBMPlexMono.ttf');
            }

            // A sound file object
            var dingdong;

            // A doorbell object (that will trigger the sound)
            var doorbell;

            function setup () {
            createCanvas(windowWidth, windowHeight);
                // Load the sound file.
            // We have included both an MP3 and an OGG version.
            soundFormats('mp3', 'ogg');
            dingdong = loadSound('assets/doorbell.mp3');
            knock = loadSound('assets/door.mp3');

            // // Create a new doorbell
            doorbell = new Doorbell(width/2 + 5, height/2 + 10, 15);
            
            door = new Door(windowWidth / 2 - 50, windowHeight / 2 - 20,   40, 70, 40, 40, 0, 0);
            }



            // On window resize, update the canvas size
            function windowResized () {
            resizeCanvas(windowWidth, windowHeight);
            }

            function draw() {
            background(20);
            doorbell.display(mouseX, mouseY);
            door.display(mouseX, mouseY);
            fill(230);
            textFont(IBM);
            text("Ring the doorbell,", width/2 - 150, height / 2 + 130);
            text("or knock on the door.", width/2 - 150, height / 2 + 150);
            stroke(230);
            strokeWeight(1.5);
            fill (230);
            // second rec
            rect(windowWidth / 2 + 80, windowHeight / 2 + 120, 30, 30);
            fill (58,134,255);
            stroke(58,134,255);
            // first rec
            rect(windowWidth / 2 + 40, windowHeight / 2 + 120, 30, 30);
            stroke(230);
                noFill();

            // third rec
                rect(windowWidth / 2 + 120, windowHeight / 2 + 120, 30, 30);
            
            // big rec
            rect(windowWidth / 2 - 150, windowHeight / 2 - 190, 300, 300);

            // square
            rect(windowWidth / 2 - 80, windowHeight / 2 - 50, 100, 100);
            
            // door
                rect(windowWidth / 2 - 50, windowHeight / 2 - 20, 40, 70, 40, 40, 0, 0);
            
                // line(windowWidth / 2 - 10, windowHeight / 2 + 25, windowWidth / 2 - 50, windowHeight / 2 + 50);
            
            // fill(233);
            //   triangle(windowWidth / 2 -11, windowHeight / 2 + 25, windowWidth / 2 - 50, windowHeight / 2 + 50, windowWidth / 2 - 11, windowHeight / 2 + 50);
            
            noFill();
            // side wall
            beginShape();
                vertex(windowWidth / 2 + 20, windowHeight / 2 - 50);
                vertex(windowWidth / 2 + 20, windowHeight / 2 + 50);
                vertex(windowWidth / 2 + 90, windowHeight / 2);
                vertex(windowWidth / 2 + 90, windowHeight / 2 - 90);
            endShape(CLOSE);
            
            // window
                beginShape();
                vertex(windowWidth / 2 + 40, windowHeight / 2 - 40);
                vertex(windowWidth / 2 + 40, windowHeight / 2 + 10);
                vertex(windowWidth / 2 + 70, windowHeight / 2 - 10);
                vertex(windowWidth / 2 + 70, windowHeight / 2 - 60);
            endShape(CLOSE);
            
            // window lines
            line(windowWidth / 2 + 65, windowHeight / 2 - 56, 
                windowWidth / 2 + 65, windowHeight / 2 - 15);
            
                line(windowWidth / 2 + 41, windowHeight / 2 + 2, 
                windowWidth / 2 + 65, windowHeight / 2 - 14);
            
                line(windowWidth / 2 + 70, windowHeight / 2 - 11, 
                windowWidth / 2 + 65, windowHeight / 2 - 14);
            
            fill(230);
            // shadow? 
            beginShape();
                vertex(windowWidth / 2 + 20, windowHeight / 2 + 50);
                vertex(windowWidth / 2 + 90, windowHeight / 2);
                vertex(windowWidth / 2 + 150, windowHeight / 2 + 10);
                vertex(windowWidth / 2 + 150, windowHeight / 2 + 50);
            endShape(CLOSE);
            
            noFill();
            
            triangle(windowWidth / 2 + 20, windowHeight / 2 - 50, windowWidth / 2 - 80, windowHeight / 2 - 50, windowWidth / 2 - 30, windowHeight / 2 - 120);
            
                beginShape();
                // triangle top
                vertex(windowWidth / 2 - 30, windowHeight / 2 - 120);
                // right rectangle left
                vertex(windowWidth / 2 + 20, windowHeight / 2 - 50);
                // right rectangle right
                vertex(windowWidth / 2 + 90, windowHeight / 2 - 90);
                vertex(windowWidth / 2 + 50, windowHeight / 2 - 150)
            endShape(CLOSE);
            
            push();
            translate(width * 0.5 - 180, height * 0.5 - 100);
            fill(58,134,255);
            stroke(20);
            strokeWeight(3);
            rotate(frameCount / 100.00)
            star(0, 0, 60, 35, 11);
            pop();  
            
                
            push();
            translate(width / 2 - 220, height / 2 - 15);
            rotate(frameCount / -20.00);
            star(0, 0, 17, 8, 4);
            pop(); 
            
            push();
            translate(width / 2 - 110, height / 2 - 150);
            rotate(frameCount / 10.00);
            star(0, 0, 10, 5, 4);
            pop(); 
            
            function star(x, y, radius1, radius2, npoints) {
                let angle = TWO_PI / npoints;
                let halfAngle = angle / 2.0;
                beginShape();
                for (let a = 0; a < TWO_PI; a += angle) {
                let sx = x + cos(a) * radius2;
                let sy = y + sin(a) * radius2;
                vertex(sx, sy);
                sx = x + cos(a + halfAngle) * radius1;
                sy = y + sin(a + halfAngle) * radius1;
                vertex(sx, sy);
                }
                endShape(CLOSE);
            }
            
            
            // top triangles
            strokeWeight(1.5);
            stroke(230);
            let count = 16;
            if(t > 90) {
                movingRight = false;
            } else if (t < 0) {
                movingRight = true;
            }
            for(let i = 0; i < count; i++) {
                beginShape(TRIANGLES);
                vertex(width / 2 - 150 + 20 * i, height / 2 - 235);
                vertex(width / 2 - 150 + 20 * i, height / 2 - 205);
                vertex(width / 2 - 150 + 8 * i + 2 * t % 180, height / 2 - 205);
                endShape();
            }
            
            if(movingRight) {
                t+= 0.3;
            } else {
                t -= 0.3;  
            }

            
            translate(width / 2 - 180 , height / 2 - 100);
            rotate(-0.3);
            smiley(0, 0, 50);
            
            
            function smiley(x, y, diameter) {
                // Face
                noFill();                  //fills the face with yellow color
                stroke(230);                          //outline in black color 
                strokeWeight(2.5);                    //outline weight set to 2

                // Smile
                var startAngle = 0.1 * PI;          //start angle of the arc
                var endAngle = 0.9 * PI;            //end angle
                var smilediameter = 0.6 * diameter;  
                arc(x, y, smilediameter, smilediameter, startAngle, endAngle);

                // Eyes
                var offset = 0.2 * diameter;
                var eyediameter = 0.1 * diameter;
                fill(230);

                ellipse(x - offset, y - offset, eyediameter, eyediameter);
                ellipse(x + offset, y - offset, eyediameter, eyediameter);
            }


            }

            function mousePressed() {
            // If the user clicks on the doorbell, play the sound!
            if (doorbell.contains(mouseX, mouseY)) {
                dingdong.play();
            }
            
            if (door.contains(mouseX, mouseY) & doorbell.contains(mouseX, mouseY) === false) {
                knock.play();
            }
            }

            // A Class to describe a "doorbell" (really a button)
            var Doorbell = function(x_, y_, r_) {
            // Location and size
            var x = x_;
            var y = y_;
            var r = r_;

            // Is a point inside the doorbell? (used for mouse rollover, etc.)
            this.contains = function(mx, my) {
                if (dist(mx, my, x, y) < r) {
                return true;
                } else {
                return false;
                }
            };

            // Show the doorbell (hardcoded colors, could be improved)
            this.display = function(mx, my) {
                if (this.contains(mx, my)) {
                fill(58,134,255);
                } else {
                fill(230);
                }
                stroke(0);
                strokeWeight(4);
                ellipse(x, y, r, r);
            };
            };

            var Door = function(x_,y_,w_,h_,r1_,r2_,r3_,r4_) {
            var x = x_;
            var y = y_;
            var w = w_;
            var h = h_;
            var r1 = r1_;
            var r2 = r2_;
            var r3 = r3_;
            var r4 = r4_;
            
                // Is a point inside the door? (used for mouse rollover, etc.)
            this.contains = function(mx, my) {
                if (dist(mx, my, windowWidth / 2 - 25, windowHeight / 2) < w) {
                return true;
                } else {
                return false;
                }
            };

            // Show the door (hardcoded colors, could be improved)
            this.display = function(mx, my) {
                if (this.contains(mx, my) & doorbell.contains(mouseX, mouseY) === false) {
                fill(58,134,255);
                } else {
                fill(230);
                }
                stroke(0);
                strokeWeight(4);
                rect(x, y, w, h, r1, r2, r3, r4);
            };
            };

        </script>
    </head>
</html>